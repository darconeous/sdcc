# Regression testing Makefile for Pic Port of SDCC
#
# note that this regression suite was started before
# the one in sdcc/regression. The regression suite in
# sdcc/regression is better suited for testing mature
# ports.
#
# GPL'd
#
# T. Scott Dattalo scott@dattalo.com
#
# This makefile provides a means by which the output
# of the SDCC Compiler can be tested. This version
# is unique to the PIC (as in Microchip PIC) port.
# As such it requires the following software:
#
#  gpasm version 0.11.1 (or greater)
#  gpsim version 0.20.7 (or greater)
#
# Usage:
#
# make
#  - without any options the whole regression test is
#    performed. The results are placed into a log file
#    (defined by $LOGFILE).
#
# make asm
#  - Creates .asm files by compiling the .c files
#
# make cod
#  - Creates .cod files by assembling the .asm files
#    (.cod files are symbolic files compatible with
#    MPASM, Microchip's assembler)
#
# make stc
#  - Creates .stc files which are script files for
#    gpsim.
#
# make clean
#  - removes all of the intermediate files created
#
# make cleancod
# make cleanasm
# make cleanstc
# make cleano
#  - removes either the .stc, .asm, .cod or .o files

# verboseness
#Q ?= # be verbose
Q ?= @ # be quiet

CC = sdcc
LINKER = gplink
TARGETPIC = 16f877
CFLAGS = -Wl,--map -I ../../device/include/pic -L ../../device/lib/pic/bin -mpic14 -pp$(TARGETPIC) -Wl,-q --no-pcode-opt

.SUFFIXES: .asm .c .cod .stc

# Results of the test are placed here:
LOGFILE = test.log

# Script file for creating gpsim scripts
CREATESTC = create_stc

# Script file for invoking gpsim
SIMULATE = simulate

# List the C files to be test here:
SRC = add.c \
      add2.c \
      add3.c \
      add4.c \
      and1.c \
      and2.c \
      arrays.c \
      b.c \
      bank1.c \
      bool1.c \
      bool2.c \
      bool3.c \
      call1.c \
      compare.c \
      compare10.c \
      compare2.c \
      compare3.c \
      compare4.c \
      compare5.c \
      compare6.c \
      compare7.c \
      compare8.c \
      compare9.c \
      configword.c \
      empty.c \
      for.c \
      inline.c \
      mult1.c \
      nestfor.c \
      or1.c \
      pointer1.c \
      ptrarg.c \
      ptrfunc.c \
      rotate1.c \
      rotate2.c \
      rotate3.c \
      rotate4.c \
      rotate5.c \
      rotate6.c \
      rotate7.c \
      string1.c \
      struct1.c \
      sub.c \
      sub2.c \
      switch1.c \
      while.c \
      xor.c

COD := $(patsubst %.c, %.cod, $(SRC))
ASM := $(patsubst %.c, %.asm, $(SRC))
O   := $(patsubst %.c, %.o,   $(SRC))
P   := $(patsubst %.c, %.p,   $(SRC))
STC := $(patsubst %.c, %.stc, $(SRC))
HEX := $(patsubst %.c, %.hex, $(SRC))
LST := $(patsubst %.c, %.lst, $(SRC))
MAP := $(patsubst %.c, %.map, $(SRC))

all:	test


# The cod files are generated by sdcc
.c.cod:
	$(Q)-$(CC) $(CFLAGS) $*.c

# The .stc files are script files for gpsim
.cod.stc:
	$(Q)-./$(CREATESTC) $*.cod $*.stc
	$(Q)-./$(SIMULATE) $*.stc $(LOGFILE)

# this will also make .stc files
#%.stc : %.cod
#	./create_stc $^ $@

# now for the dependencies

cod : $(COD)

o : $(O)

asm : $(ASM)

stc : $(STC)
	echo $(STC)

test:	$(STC)
	$(Q)echo "Done - Results are in $(LOGFILE)"

cleancod:
	files="$(COD)" ; \
	for f in $$files ; do \
	  if [ -f $$f ]; then rm $$f; fi \
	done ; \

cleano:
	files="$(O)" ; \
	for f in $$files ; do \
	  if [ -f $$f ]; then rm $$f; fi \
	done ; \

cleanp:
	files="$(P)" ; \
	for f in $$files ; do \
	  if [ -f $$f ]; then rm $$f; fi \
	done ; \

cleanasm:
	files="$(ASM)" ; \
	for f in $$files ; do \
	  if [ -f $$f ]; then rm $$f; fi \
	done ; \

cleanstc:
	files="$(STC)" ; \
	for f in $$files ; do \
	  if [ -f $$f ]; then rm $$f; fi \
	done ; \

cleanhex:
	files="$(HEX)" ; \
	for f in $$files ; do \
	  if [ -f $$f ]; then rm $$f; fi \
	done ; \

cleanlst:
	files="$(LST)" ; \
	for f in $$files ; do \
	  if [ -f $$f ]; then rm $$f; fi \
	done ; \

cleanmap:
	files="$(MAP)" ; \
	for f in $$files ; do \
	  if [ -f $$f ]; then rm $$f; fi \
	done ; \

clean: cleancod cleanasm cleanstc cleano cleanp cleanhex cleanlst cleanmap
	if [ -f "$(LOGFILE)" ]; then rm $(LOGFILE); fi
